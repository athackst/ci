name: Release draft
description: Draft release notes for your next release based on merged PRs.
inputs:
  github_token:
    description: GitHub token used to draft the release.
    required: true
  tag-suffix:
    description: Optional suffix appended to tag-template (test/debug use).
    required: false
    default: ""
outputs:
  tag_name:
    description: The tag name of the drafted release.
    value: ${{ steps.resolve-version.outputs.tag_name }}
runs:
  using: composite
  steps:
    - name: Checkout repository history
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Ensure at least one local tag exists
      shell: bash
      run: |
        if [ -z "$(git tag --list)" ]; then
          git tag v0.0.0 "${GITHUB_SHA}"
          echo "Bootstrapped local tag v0.0.0 for changelog generation."
        fi

    - name: Setup changelog config
      shell: bash
      run: |
        mkdir -p .github
        cp "${{ github.action_path }}/changelog-config.json" .github/release-changelog-config.json

    - name: Build changelog
      id: changelog
      uses: mikepenz/release-changelog-builder-action@v6.0.1
      with:
        configuration: .github/release-changelog-config.json
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}

    - name: Resolve next version
      id: resolve-version
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        REPO: ${{ github.repository }}
        FROM_TAG: ${{ steps.changelog.outputs.fromTag }}
        PR_IDS: ${{ steps.changelog.outputs.pull_requests }}
        TAG_SUFFIX: ${{ inputs.tag-suffix }}
      run: |
        python3 - <<'PY'
        import json
        import os
        import re
        import urllib.request

        def parse_version(tag: str):
            if not tag:
                return (0, 0, 0)
            match = re.match(r"^v?(\d+)\.(\d+)\.(\d+)$", tag.strip())
            if not match:
                return (0, 0, 0)
            return tuple(int(x) for x in match.groups())

        def bump_version(version, bump):
            major, minor, patch = version
            if bump == "major":
                return (major + 1, 0, 0)
            if bump == "minor":
                return (major, minor + 1, 0)
            return (major, minor, patch + 1)

        token = os.environ["GH_TOKEN"]
        repo = os.environ["REPO"]
        from_tag = os.environ.get("FROM_TAG", "")
        pr_ids_raw = os.environ.get("PR_IDS", "")
        tag_suffix = os.environ.get("TAG_SUFFIX", "")

        pr_ids = [x.strip() for x in pr_ids_raw.split(",") if x.strip()]
        labels = set()
        for pr_id in pr_ids:
            url = f"https://api.github.com/repos/{repo}/pulls/{pr_id}"
            req = urllib.request.Request(
                url,
                headers={
                    "Authorization": f"Bearer {token}",
                    "Accept": "application/vnd.github+json",
                    "User-Agent": "release-draft-action",
                },
            )
            with urllib.request.urlopen(req) as resp:
                payload = json.loads(resp.read().decode("utf-8"))
            for label in payload.get("labels", []):
                name = label.get("name")
                if name:
                    labels.add(name)

        if "major" in labels or "breaking" in labels:
            bump = "major"
        elif "enhancement" in labels:
            bump = "minor"
        else:
            bump = "patch"

        next_version = bump_version(parse_version(from_tag), bump)
        version = f"{next_version[0]}.{next_version[1]}.{next_version[2]}"
        tag_name = f"v{version}{tag_suffix}"
        release_name = f"Release v{version}{tag_suffix}"

        output_path = os.environ["GITHUB_OUTPUT"]
        with open(output_path, "a", encoding="utf-8") as fh:
            fh.write(f"tag_name={tag_name}\n")
            fh.write(f"release_name={release_name}\n")
        PY

    - name: Create or update draft release
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        TAG_NAME: ${{ steps.resolve-version.outputs.tag_name }}
        RELEASE_NAME: ${{ steps.resolve-version.outputs.release_name }}
        CHANGELOG: ${{ steps.changelog.outputs.changelog }}
      run: |
        set -euo pipefail

        EXISTING_RELEASE_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}" 2>/dev/null || true)"
        if [ -n "$EXISTING_RELEASE_JSON" ]; then
          DRAFT_STATE="$(jq -r '.draft' <<< "$EXISTING_RELEASE_JSON")"
          RELEASE_ID="$(jq -r '.id' <<< "$EXISTING_RELEASE_JSON")"
          if [ "$DRAFT_STATE" != "true" ]; then
            echo "Release ${TAG_NAME} already exists and is not a draft."
            exit 1
          fi

          jq -n \
            --arg name "$RELEASE_NAME" \
            --arg body "$CHANGELOG" \
            '{name: $name, body: $body, draft: true}' > /tmp/release-payload.json
          gh api \
            -X PATCH \
            "repos/${GITHUB_REPOSITORY}/releases/${RELEASE_ID}" \
            --input /tmp/release-payload.json >/dev/null
          echo "Updated existing draft release ${TAG_NAME} (${RELEASE_ID})."
        else
          jq -n \
            --arg tag_name "$TAG_NAME" \
            --arg name "$RELEASE_NAME" \
            --arg body "$CHANGELOG" \
            '{tag_name: $tag_name, name: $name, body: $body, draft: true, prerelease: false}' > /tmp/release-payload.json
          gh api \
            -X POST \
            "repos/${GITHUB_REPOSITORY}/releases" \
            --input /tmp/release-payload.json >/dev/null
          echo "Created new draft release ${TAG_NAME}."
        fi
